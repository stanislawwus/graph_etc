def read_csv(file_path, orientated = False):
    with open(file_path, "r+", encoding="utf-8") as f:
        content = f.readlines()
    content = [i.strip().split(",")[:2] for i in content]
    edges = [[int(i.strip()) for i in line] for line in content]
    graph = {}
    for a, b in edges:
        if not orientated:
            if a not in graph:
                graph[a] = []
            if b not in graph:
                graph[b] = []
            graph[a].append(b)
            graph[b].append(a)
        else:
            if a not in graph:
                graph[a] = []
            graph[a].append(b)
    return graph

def main(graph):
    res=[]
    def hamilton(graf, size, start, path=[]):
        if start not in path:
            path.append(start)
            if len(path)==size:
                res.append(path)
                return path
            for start_next in graf[start]:
                res_path = [i for i in path]
                hamilton (graf, size, start_next, res_path)
    for i in list(graph.keys()):
        hamilton(graph, len(graph), i, [])
    check=[]#for orientated graphs
    check2=0
    if len(res)!=0:
        for i in res:
            check.append(i[0])
    check=set(check)
    for i in check:
        if i in list(graph.keys()):
            check2+=1
    if check2==len(list(graph.keys())) and check2!=0:
        return res[0]
    if len(res)!=0:
        return f'no hamilton cycle but this graph has hamilton path or pathes: {res}'
    return 'miss input, try again but with the new graph'

def eiler_cycle(graph, orientated = False):
    def is_connected(graph):
        visited = set()

        def dfs(vertex):
            visited.add(vertex)
            for degree in graph[vertex]:
                if degree not in visited:
                    dfs(degree)

        start_vertex = next(iter(graph))
        dfs(start_vertex)

        return len(visited) == len(graph)
    if not is_connected(graph):
        return 'Eulerian cycle does not exist.'
    if orientated is False:
        for items in graph.items():
            if len(items[1]) % 2 != 0:
                return 'Eulerian cycle does not exist'
        current_vertex = list(graph.keys())[0]
        eulerian_cycle = [current_vertex]
        while graph[current_vertex]:
            next_vertex = graph[current_vertex].pop(0)
            graph[next_vertex].remove(current_vertex)
            current_vertex = next_vertex
            eulerian_cycle.append(current_vertex)
        return eulerian_cycle
    else:
        graph_vertex_degrees = {vertex: len(neighbors) for vertex, neighbors in graph.items()}
        current_vertex = None
        for vertex, outdegree in graph_vertex_degrees.items():
            if outdegree > 0:
                current_vertex = vertex
                break

        eulerian_cycle = [current_vertex]
        while graph[current_vertex]:
            next_vertex = graph[current_vertex].pop(0)
            graph_vertex_degrees[current_vertex] -= 1
            current_vertex = next_vertex
            eulerian_cycle.append(current_vertex)

        while any(graph_vertex_degrees.values()):
            for i, vertex in enumerate(eulerian_cycle):
                if graph[vertex]:
                    subcycle = [vertex]
                    while graph[vertex]:
                        next_vertex = graph[vertex].pop(0)
                        graph_vertex_degrees[vertex] -= 1
                        vertex = next_vertex
                        subcycle.append(vertex)
                    eulerian_cycle = eulerian_cycle[:i+1] + subcycle + eulerian_cycle[i+1:]
        return eulerian_cycle

def izomorf_check():
    pass


def paint_graph():
    pass


print(read_csv("ff.csv", True))
