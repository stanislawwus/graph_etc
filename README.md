Функція izomorf_check передбачає, що вона буде викликана для 2-ох графів. Перевіряє, чи є ці графи ізоморфними.
Загалом не існує конкретного підходу, який би точно перевіряв, чи є графи ізоморфними, але я використав основні алгоритми перевірки:

1 перевірка:
  Це є перевірка, чи у двох графах є одинакова кількість вершин

    if len(graph1) != len(graph2):
        flag = False

2 перевірка:
  Це є перевірка, чи у двох графах є одинакові степені вершин

  Створюємо нові словники, у яких ключ - це вершина графа, а значення - кількість ребер, які виходять з неї.

    dct_len_1 = [len(value) for value in graph1.values()]
    dct_len_2 = [len(value) for value in graph2.values()]

    if sorted(dct_len_1) != sorted(dct_len_2):
        flag = False

3 перевірка:
  Це є перевірка, чи у двох графах є однакова кількість ребер

  Створюємо нові списки, у які добавляємо кортежі з вершиною і суміжною вершиною.

    edg_lst_1 = []
    edg_lst_2 = []

    for key, value in graph1.items():
        for i in value:
            edg_lst_1.append((key, i))
    
    for key, value in graph2.items():
        for i in value:
            edg_lst_2.append((key, i))
    
    if len(edg_lst_1) != len(edg_lst_2):
        flag = False

4 перевірка:
  Це є перевірка, чи у двох графах є або немає ейлерового цикла

  Створюємо нові списки, у які добавляємо True, якщо степінь вершини парна, False, якщо непарна.
  Потім змінній присвоюємо True, якщо у цих списках всі елементи True, але якщо хоча би 1 False, тоді False

    lst_el_1 = all([i % 2 == 0 for i in dct_len_1])
    lst_el_2 = all([i % 2 == 0 for i in dct_len_2])

    if lst_el_1 != lst_el_2:
        flag = False


5 перевірка:
  Це є перевірка, чи у двох графах є або немає ейлерового цикла (якщо граф орієнтований)

  Створюємо нові змінні зі значенням 0, і якщо степінь вершини виходить непарне число, тоді добавляємо до цієї змінної +1.
  Потім, якщо ця змінна дорівнює 2, тоді перевіряємо, чи друга змінна також дорівнює 2.

    count1 = 0

    for item in dct_len_1:
        if item % 2 != 0:
            count1 += 1
    
    count2 = 0

    for item in dct_len_2:
        if item % 2 != 0:
            count2 += 1

    if count1 == 2 and count2 != 2:
        flag = False
    
    if count1 != 2 and count2 == 2:
        flag = False
